/*
 * Pixmap embed tool for KWin clients (version 1.0)
 *
 * Copyright (C) 2004 Fredrik Höglund <fredrik@kde.org>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the license, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <qimage.h>
#include <qtextstream.h>
#include <qregexp.h>
#include <qfile.h>
#include <qfileinfo.h>
#include <qdatetime.h>

#include <iostream>

static const char *className     = "KontactImageDb";
static const char *namespaceName = "Kontact";

struct EmbedImage {
	QString string;
	int width;
	int height;
	bool alpha;
	QString name;
};

class Embedder {
	public:
		Embedder();
		~Embedder();

		void embed( const char * );
		void writeIndex();
	
	private:
		bool isPrime( int num );

		QFile *file;
		QPtrList<EmbedImage> *index;
		QTextStream stream;
};

Embedder::Embedder()
{
	QDateTime date( QDateTime::currentDateTime() );
	QString datestring( date.toString() );
	
	file = new QFile( "tiles.h" );
	file->open( IO_WriteOnly | IO_Truncate );

	stream.setDevice( file );
	
	stream << "/*\n";
	stream << " * Generated by embedtool 1.0 on " << datestring << endl;
	stream << " */\n\n";
	
	stream << "#ifndef __TILES_H\n";
	stream << "#define __TILES_H\n\n";
	stream << "#include <qimage.h>\n"; 
	stream << "#include <qdict.h>\n\n";
	stream << "namespace " << namespaceName << " {\n\n";
	
	index = new QPtrList<EmbedImage>;
	index->setAutoDelete( true );
}

Embedder::~Embedder()
{	
	stream << "} // namespace " << namespaceName << "\n\n";
	stream << "#endif // __TILES_H\n\n";
	stream << "// vim: set noet ts=4 sw=4:\n";

	file->close();
	delete file;
	delete index;
}

void Embedder::embed( const char *name )
{
	QFileInfo   fileinfo( name );
	QString     basename( fileinfo.baseName() );
	QString     codename( basename );
	QImage      image( name );
	
	codename = codename.replace( QRegExp("[^a-zA-Z0-9]"), "_" );
	
	stream << "\tstatic const QRgb " << codename << "_data[] = {" << endl << "\t\t";
	stream.setf( QTextStream::hex | QTextStream::right );
	stream.fill( '0' );
	
	int pixels = image.width() * image.height();
	Q_UINT32 *data = reinterpret_cast<Q_UINT32*>( image.bits() );
	bool hasAlpha = false;

	
	for ( int i = 0, j = 0; i < pixels; i++ ) {
		if ( qAlpha( *data ) && qAlpha( *data ) != 0xff )
			hasAlpha = true;
		
		stream << "0x" << qSetW(8) << *(data++);
		
		if ( i != pixels-1 ) {
			stream << ',';
		
			if ( j++ > 4 ) {
				j = 0;
				stream << endl << "\t\t";
			} else
				stream << ' ';
		}
	}

	stream.reset();
	
	stream << endl << "\t}; // " << codename << "_data" << endl << endl;

	EmbedImage *imginfo = new EmbedImage;
	imginfo->width = image.width();
	imginfo->height = image.height();
	imginfo->alpha = hasAlpha;
	imginfo->name = codename;
	imginfo->string = basename;
	index->append( imginfo ); 
}

bool Embedder::isPrime( int num )
{
	for ( int i = 2; i < num; i++ )
		if ( (num % i) == 0 )
			return false;

	return true;
}

void Embedder::writeIndex()
{
	stream << "\tstruct EmbedImage {\n";
	stream << "\t\tconst char *name;\n";
	stream << "\t\tint width;\n";
	stream << "\t\tint height;\n";
	stream << "\t\tbool alpha;\n";
	stream << "\t\tconst QRgb *data;\n";
	stream << "\t};\n\n";

	uint i = 0;
	stream << "\tstatic const EmbedImage image_db[] = {\n";
	for ( EmbedImage *image = index->first(); image; image = index->next() )
	{
		stream << "\t\t{ \"" << image->string << "\", "
			<< image->width << ", " << image->height <<
			", " << (image->alpha ? "true" : "false")
			<< ", " << image->name << "_data }";
		if ( i++ < index->count() - 1 )
			stream << ',';
		stream << endl;
	}
	stream << "\t};\n\n";

	uint prime = index->count();
	while ( !isPrime( prime ) )
		prime++;

	stream << "\tclass " << className << " {\n";
	stream << "\tprivate:\n";
	stream << "\t\tstatic " << className << " *m_inst;\n";
	stream << "\t\tQDict<QImage> *db;\n\n";
	stream << "\t\t" << className << "() {\n";
	stream << "\t\t\tdb = new QDict<QImage>( " << prime << " );\n";
	stream << "\t\t\tdb->setAutoDelete( true );\n\n";
	stream << "\t\t\tfor ( int i = 0; i < " << index->count() << "; i++ ) {\n";
	stream << "\t\t\t\tQImage *img = new QImage( (uchar*)image_db[i].data,\n";
	stream << "\t\t\t\t\t\timage_db[i].width, image_db[i].height,\n";
	stream << "\t\t\t\t\t\t32, NULL, 0, QImage::LittleEndian );\n\n";
	stream << "\t\t\t\tif ( image_db[i].alpha )\n";
	stream << "\t\t\t\t\timg->setAlphaBuffer( true );\n\n";
	stream << "\t\t\t\tdb->insert( image_db[i].name, img );\n";
	stream << "\t\t\t}\n";
	stream << "\t\t}\n\n";
	stream << "\t\t~" << className << "() {\n";
	stream << "\t\t\tdelete db;\n";
	stream << "\t\t}\n\n";
	stream << "\tpublic:\n";
	stream << "\t\tstatic " << className << "* instance() {\n";	
	stream << "\t\t\tif ( ! m_inst ) m_inst = new " << className << ";\n";
	stream << "\t\t\treturn m_inst;\n";
	stream << "\t\t}\n\n";
	stream << "\t\tstatic void release() {\n";
	stream << "\t\t\tdelete m_inst;\n";
	stream << "\t\t\tm_inst = NULL;\n";
	stream << "\t\t}\n\n";
	stream << "\t\tQImage *image( const QString &name ) const {\n";
	stream << "\t\t\treturn db->find( name );\n";
	stream << "\t\t}\n\n";
	stream << "\t}; // class " << className << "\n\n";
	stream << "\t" << className << " *" << className << "::m_inst = NULL;\n\n";
}

int main( int argc, char **argv )
{
	if ( argc < 2 ) {
		std::cerr << "Insufficient arguments" << std::endl;
		return 1;
	}

	Embedder e;

	for ( int i = 1; i < argc; i++ )
	{
		std::cout << argv[i] << std::endl;
		e.embed( argv[i] );
	}

	e.writeIndex();

	return 0;
}

// vim: set noet ts=4 sw=4:

